/**
 * Generated by Scrooge
 *   version: ?
 *   rev: ?
 *   built at: ?
 */
package com.twitter.scrooge.test.gold.thriftscala

import com.twitter.io.Buf
import com.twitter.scrooge.{
  LazyTProtocol,
  TFieldBlob,
  ThriftStruct,
  ThriftStructCodec3,
  ThriftStructFieldInfo,
  ThriftStructMetaData,
  ValidatingThriftStruct,
  ValidatingThriftStructCodec3
}
import com.twitter.scrooge.adapt.{AccessRecorder, AdaptTProtocol, Decoder}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.Builder
import scala.collection.Map

/**
 * Request struct docstring
 */
object Request extends ValidatingThriftStructCodec3[Request] {
  val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
  val Struct: TStruct = new TStruct("Request")
  val AListField: TField = new TField("aList", TType.LIST, 1)
  val AListFieldManifest: Manifest[_root_.scala.collection.Seq[String]] = implicitly[Manifest[_root_.scala.collection.Seq[String]]]
  val ASetField: TField = new TField("aSet", TType.SET, 2)
  val ASetFieldManifest: Manifest[_root_.scala.collection.Set[Int]] = implicitly[Manifest[_root_.scala.collection.Set[Int]]]
  val AMapField: TField = new TField("aMap", TType.MAP, 3)
  val AMapFieldManifest: Manifest[_root_.scala.collection.Map[Long, Long]] = implicitly[Manifest[_root_.scala.collection.Map[Long, Long]]]
  val ARequestField: TField = new TField("aRequest", TType.STRUCT, 4)
  val ARequestFieldManifest: Manifest[com.twitter.scrooge.test.gold.thriftscala.Request] = implicitly[Manifest[com.twitter.scrooge.test.gold.thriftscala.Request]]
  val SubRequestsField: TField = new TField("subRequests", TType.LIST, 5)
  val SubRequestsFieldManifest: Manifest[_root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request]] = implicitly[Manifest[_root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request]]]
  val HasDefaultField: TField = new TField("hasDefault", TType.STRING, 6)
  val HasDefaultFieldManifest: Manifest[String] = implicitly[Manifest[String]]
  val NoCommentField: TField = new TField("noComment", TType.I64, 7)
  val NoCommentFieldManifest: Manifest[Long] = implicitly[Manifest[Long]]
  val DoubleSlashCommentField: TField = new TField("doubleSlashComment", TType.I64, 8)
  val DoubleSlashCommentFieldManifest: Manifest[Long] = implicitly[Manifest[Long]]
  val HashtagCommentField: TField = new TField("hashtagComment", TType.I64, 9)
  val HashtagCommentFieldManifest: Manifest[Long] = implicitly[Manifest[Long]]
  val SingleAsteriskCommentField: TField = new TField("singleAsteriskComment", TType.I64, 10)
  val SingleAsteriskCommentFieldManifest: Manifest[Long] = implicitly[Manifest[Long]]
  val DocStringCommentField: TField = new TField("docStringComment", TType.I64, 11)
  val DocStringCommentFieldManifest: Manifest[Long] = implicitly[Manifest[Long]]
  val RecRequestField: TField = new TField("recRequest", TType.STRUCT, 12)
  val RecRequestFieldManifest: Manifest[com.twitter.scrooge.test.gold.thriftscala.Recursive] = implicitly[Manifest[com.twitter.scrooge.test.gold.thriftscala.Recursive]]
  val RequiredFieldField: TField = new TField("requiredField", TType.STRING, 13)
  val RequiredFieldFieldManifest: Manifest[String] = implicitly[Manifest[String]]
  val ConstructionRequiredFieldField: TField = new TField("constructionRequiredField", TType.I64, 14)
  val ConstructionRequiredFieldFieldManifest: Manifest[Long] = implicitly[Manifest[Long]]
  val AnInt8Field: TField = new TField("anInt8", TType.BYTE, 15)
  val AnInt8FieldManifest: Manifest[Byte] = implicitly[Manifest[Byte]]

  /**
   * Field information in declaration order.
   */
  lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    new ThriftStructFieldInfo(
      AListField,
      false,
      false,
      AListFieldManifest,
      _root_.scala.None,
      _root_.scala.Some(implicitly[Manifest[String]]),
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      ASetField,
      false,
      false,
      ASetFieldManifest,
      _root_.scala.None,
      _root_.scala.Some(implicitly[Manifest[Int]]),
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      AMapField,
      false,
      false,
      AMapFieldManifest,
      _root_.scala.Some(implicitly[Manifest[Long]]),
      _root_.scala.Some(implicitly[Manifest[Long]]),
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      ARequestField,
      true,
      false,
      ARequestFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      SubRequestsField,
      false,
      false,
      SubRequestsFieldManifest,
      _root_.scala.None,
      _root_.scala.Some(implicitly[Manifest[com.twitter.scrooge.test.gold.thriftscala.Request]]),
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      HasDefaultField,
      false,
      false,
      HasDefaultFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      Some[String]("the_default")
    ),
    new ThriftStructFieldInfo(
      NoCommentField,
      true,
      false,
      NoCommentFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      DoubleSlashCommentField,
      true,
      false,
      DoubleSlashCommentFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      HashtagCommentField,
      true,
      false,
      HashtagCommentFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map(
        "a.b.c" -> "ignored"
      ),
      None
    ),
    new ThriftStructFieldInfo(
      SingleAsteriskCommentField,
      true,
      false,
      SingleAsteriskCommentFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map(
        "s.field.annotation.one" -> "a",
        "two" -> "b"
      ),
      None
    ),
    new ThriftStructFieldInfo(
      DocStringCommentField,
      true,
      false,
      DocStringCommentFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      RecRequestField,
      true,
      false,
      RecRequestFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      RequiredFieldField,
      false,
      true,
      RequiredFieldFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    ),
    new ThriftStructFieldInfo(
      ConstructionRequiredFieldField,
      true,
      false,
      ConstructionRequiredFieldFieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map(
        "construction_required" -> "true"
      ),
      None
    ),
    new ThriftStructFieldInfo(
      AnInt8Field,
      true,
      false,
      AnInt8FieldManifest,
      _root_.scala.None,
      _root_.scala.None,
      immutable$Map.empty[String, String],
      immutable$Map.empty[String, String],
      None
    )
  )

  lazy val structAnnotations: immutable$Map[String, String] =
    immutable$Map[String, String](
        "s.annotation.one" -> "something",
        "s.annotation.two" -> "other"
    )

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: Request): Unit = {
    if (_item.requiredField == null) throw new TProtocolException("Required field requiredField cannot be null")
  }

  /**
   * Checks that the struct is a valid as a new instance. If there are any missing required or
   * construction required fields, return a non-empty list.
   */
  def validateNewInstance(item: Request): scala.Seq[com.twitter.scrooge.validation.Issue] = {
    val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]

    buf ++= validateField(item.aList)
    buf ++= validateField(item.aSet)
    buf ++= validateField(item.aMap)
    buf ++= validateField(item.aRequest)
    buf ++= validateField(item.subRequests)
    buf ++= validateField(item.hasDefault)
    buf ++= validateField(item.noComment)
    buf ++= validateField(item.doubleSlashComment)
    buf ++= validateField(item.hashtagComment)
    buf ++= validateField(item.singleAsteriskComment)
    buf ++= validateField(item.docStringComment)
    buf ++= validateField(item.recRequest)
    if (item.requiredField == null)
      buf += com.twitter.scrooge.validation.MissingRequiredField(fieldInfos.apply(12))
    buf ++= validateField(item.requiredField)
    if (item.constructionRequiredField.isEmpty)
      buf += com.twitter.scrooge.validation.MissingConstructionRequiredField(
        fieldInfos.apply(13)
      )
    buf ++= validateField(item.constructionRequiredField)
    buf ++= validateField(item.anInt8)
    buf.toList
  }

  def withoutPassthroughFields(original: Request): Request =
    new Immutable(
      aList =
        {
          val field = original.aList
          field.map { field =>
            field
          }
        },
      aSet =
        {
          val field = original.aSet
          field.map { field =>
            field
          }
        },
      aMap =
        {
          val field = original.aMap
          field.map { case (key, value) =>
              val newKey = {
              val field = key
              field
            }
  
          
              val newValue = {
              val field = value
              field
            }
  
          
            newKey -> newValue
          }
        },
      aRequest =
        {
          val field = original.aRequest
          field.map { field =>
            com.twitter.scrooge.test.gold.thriftscala.Request.withoutPassthroughFields(field)
          }
        },
      subRequests =
        {
          val field = original.subRequests
          field.map { field =>
            com.twitter.scrooge.test.gold.thriftscala.Request.withoutPassthroughFields(field)
          }
        },
      hasDefault =
        {
          val field = original.hasDefault
          field
        },
      noComment =
        {
          val field = original.noComment
          field.map { field =>
            field
          }
        },
      doubleSlashComment =
        {
          val field = original.doubleSlashComment
          field.map { field =>
            field
          }
        },
      hashtagComment =
        {
          val field = original.hashtagComment
          field.map { field =>
            field
          }
        },
      singleAsteriskComment =
        {
          val field = original.singleAsteriskComment
          field.map { field =>
            field
          }
        },
      docStringComment =
        {
          val field = original.docStringComment
          field.map { field =>
            field
          }
        },
      recRequest =
        {
          val field = original.recRequest
          field.map { field =>
            com.twitter.scrooge.test.gold.thriftscala.Recursive.withoutPassthroughFields(field)
          }
        },
      requiredField =
        {
          val field = original.requiredField
          field
        },
      constructionRequiredField =
        {
          val field = original.constructionRequiredField
          field.map { field =>
            field
          }
        },
      anInt8 =
        {
          val field = original.anInt8
          field.map { field =>
            field
          }
        }
    )

  override def encode(_item: Request, _oproto: TProtocol): Unit = {
    _item.write(_oproto)
  }

  @volatile private[this] var adaptiveDecoder: Decoder[Request] = _

  private[this] val accessRecordingDecoderBuilder: AccessRecorder => Decoder[Request] = { accessRecorder =>
    new Decoder[Request] {
      def apply(prot: AdaptTProtocol): Request = new AccessRecordingWrapper(lazyDecode(prot), accessRecorder)
    }
  }
  private[this] val fallbackDecoder = new Decoder[Request] {
    def apply(prot: AdaptTProtocol): Request = lazyDecode(prot)
  }
  private[this] def adaptiveDecode(_iprot: AdaptTProtocol): Request = {
    val adaptContext = _iprot.adaptContext
    val reloadRequired = adaptContext.shouldReloadDecoder
    synchronized {
      if (adaptiveDecoder == null || reloadRequired) {
        adaptiveDecoder = adaptContext.buildDecoder(this, fallbackDecoder, accessRecordingDecoderBuilder)
      }
    }
    adaptiveDecoder(_iprot)
  }

  /**
   * AccessRecordingWrapper keeps track of fields that are accessed while
   * delegating to underlying struct.
   */
  private[this] class AccessRecordingWrapper(underlying: Request, accessRecorder: AccessRecorder) extends Request {
    override def aList: _root_.scala.collection.Seq[String] = {
      accessRecorder.fieldAccessed(1)
      underlying.aList
    }
    override def aSet: _root_.scala.collection.Set[Int] = {
      accessRecorder.fieldAccessed(2)
      underlying.aSet
    }
    override def aMap: _root_.scala.collection.Map[Long, Long] = {
      accessRecorder.fieldAccessed(3)
      underlying.aMap
    }
    override def aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = {
      accessRecorder.fieldAccessed(4)
      underlying.aRequest
    }
    override def subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = {
      accessRecorder.fieldAccessed(5)
      underlying.subRequests
    }
    override def hasDefault: String = {
      accessRecorder.fieldAccessed(6)
      underlying.hasDefault
    }
    override def noComment: _root_.scala.Option[Long] = {
      accessRecorder.fieldAccessed(7)
      underlying.noComment
    }
    override def doubleSlashComment: _root_.scala.Option[Long] = {
      accessRecorder.fieldAccessed(8)
      underlying.doubleSlashComment
    }
    override def hashtagComment: _root_.scala.Option[Long] = {
      accessRecorder.fieldAccessed(9)
      underlying.hashtagComment
    }
    override def singleAsteriskComment: _root_.scala.Option[Long] = {
      accessRecorder.fieldAccessed(10)
      underlying.singleAsteriskComment
    }
    override def docStringComment: _root_.scala.Option[Long] = {
      accessRecorder.fieldAccessed(11)
      underlying.docStringComment
    }
    override def recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = {
      accessRecorder.fieldAccessed(12)
      underlying.recRequest
    }
    override def requiredField: String = {
      accessRecorder.fieldAccessed(13)
      underlying.requiredField
    }
    override def constructionRequiredField: _root_.scala.Option[Long] = {
      accessRecorder.fieldAccessed(14)
      underlying.constructionRequiredField
    }
    override def anInt8: _root_.scala.Option[Byte] = {
      accessRecorder.fieldAccessed(15)
      underlying.anInt8
    }
    override def write(_oprot: TProtocol): Unit = underlying.write(_oprot)

    override def _passthroughFields: immutable$Map[Short, TFieldBlob] = underlying._passthroughFields
  }

  private[this] def lazyDecode(_iprot: LazyTProtocol): Request = {

    var aList: _root_.scala.collection.Seq[String] = _root_.scala.collection.Seq[String]()
    var aSet: _root_.scala.collection.Set[Int] = _root_.scala.collection.Set[Int]()
    var aMap: _root_.scala.collection.Map[Long, Long] = _root_.scala.collection.Map[Long, Long]()
    var aRequest: Option[com.twitter.scrooge.test.gold.thriftscala.Request] = None
    var subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request]()
    var hasDefaultOffset: Int = -1
    var noCommentOffset: Int = -1
    var doubleSlashCommentOffset: Int = -1
    var hashtagCommentOffset: Int = -1
    var singleAsteriskCommentOffset: Int = -1
    var docStringCommentOffset: Int = -1
    var recRequest: Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = None
    var requiredFieldOffset: Int = -1
    var _got_requiredField = false
    var constructionRequiredFieldOffset: Int = -1
    var anInt8Offset: Int = -1

    var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
    var _done = false
    val _start_offset = _iprot.offset

    _iprot.readStructBegin()
    while (!_done) {
      val _field = _iprot.readFieldBegin()
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 =>
            _field.`type` match {
              case TType.LIST =>
    
                aList = readAListValue(_iprot)
              case _actualType =>
                val _expectedType = TType.LIST
                throw new TProtocolException(
                  "Received wrong type for field 'aList' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 2 =>
            _field.`type` match {
              case TType.SET =>
    
                aSet = readASetValue(_iprot)
              case _actualType =>
                val _expectedType = TType.SET
                throw new TProtocolException(
                  "Received wrong type for field 'aSet' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 3 =>
            _field.`type` match {
              case TType.MAP =>
    
                aMap = readAMapValue(_iprot)
              case _actualType =>
                val _expectedType = TType.MAP
                throw new TProtocolException(
                  "Received wrong type for field 'aMap' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 4 =>
            _field.`type` match {
              case TType.STRUCT =>
    
                aRequest = Some(readARequestValue(_iprot))
              case _actualType =>
                val _expectedType = TType.STRUCT
                throw new TProtocolException(
                  "Received wrong type for field 'aRequest' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 5 =>
            _field.`type` match {
              case TType.LIST =>
    
                subRequests = readSubRequestsValue(_iprot)
              case _actualType =>
                val _expectedType = TType.LIST
                throw new TProtocolException(
                  "Received wrong type for field 'subRequests' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 6 =>
            _field.`type` match {
              case TType.STRING =>
                hasDefaultOffset = _iprot.offsetSkipString
    
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'hasDefault' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 7 =>
            _field.`type` match {
              case TType.I64 =>
                noCommentOffset = _iprot.offsetSkipI64
    
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'noComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 8 =>
            _field.`type` match {
              case TType.I64 =>
                doubleSlashCommentOffset = _iprot.offsetSkipI64
    
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'doubleSlashComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 9 =>
            _field.`type` match {
              case TType.I64 =>
                hashtagCommentOffset = _iprot.offsetSkipI64
    
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'hashtagComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 10 =>
            _field.`type` match {
              case TType.I64 =>
                singleAsteriskCommentOffset = _iprot.offsetSkipI64
    
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'singleAsteriskComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 11 =>
            _field.`type` match {
              case TType.I64 =>
                docStringCommentOffset = _iprot.offsetSkipI64
    
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'docStringComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 12 =>
            _field.`type` match {
              case TType.STRUCT =>
    
                recRequest = Some(readRecRequestValue(_iprot))
              case _actualType =>
                val _expectedType = TType.STRUCT
                throw new TProtocolException(
                  "Received wrong type for field 'recRequest' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 13 =>
            _field.`type` match {
              case TType.STRING =>
                requiredFieldOffset = _iprot.offsetSkipString
    
                _got_requiredField = true
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'requiredField' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 14 =>
            _field.`type` match {
              case TType.I64 =>
                constructionRequiredFieldOffset = _iprot.offsetSkipI64
    
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'constructionRequiredField' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 15 =>
            _field.`type` match {
              case TType.BYTE =>
                anInt8Offset = _iprot.offsetSkipByte
    
              case _actualType =>
                val _expectedType = TType.BYTE
                throw new TProtocolException(
                  "Received wrong type for field 'anInt8' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case _ =>
            if (_passthroughFields == null)
              _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
            _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()

    if (!_got_requiredField) throw new TProtocolException("Required field 'requiredField' was not found in serialized data for struct Request")
    new LazyImmutable(
      _iprot,
      _iprot.buffer,
      _start_offset,
      _iprot.offset,
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefaultOffset,
      noCommentOffset,
      doubleSlashCommentOffset,
      hashtagCommentOffset,
      singleAsteriskCommentOffset,
      docStringCommentOffset,
      recRequest,
      requiredFieldOffset,
      constructionRequiredFieldOffset,
      anInt8Offset,
      if (_passthroughFields == null)
        NoPassthroughFields
      else
        _passthroughFields.result()
    )
  }

  override def decode(_iprot: TProtocol): Request =
    _iprot match {
      case i: AdaptTProtocol => adaptiveDecode(i)
      case i: LazyTProtocol => lazyDecode(i)
      case i => eagerDecode(i)
    }

  private[thriftscala] def eagerDecode(_iprot: TProtocol): Request = {
    var aList: _root_.scala.collection.Seq[String] = _root_.scala.collection.Seq[String]()
    var aSet: _root_.scala.collection.Set[Int] = _root_.scala.collection.Set[Int]()
    var aMap: _root_.scala.collection.Map[Long, Long] = _root_.scala.collection.Map[Long, Long]()
    var aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = _root_.scala.None
    var subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request]()
    var hasDefault: String = "the_default"
    var noComment: _root_.scala.Option[Long] = _root_.scala.None
    var doubleSlashComment: _root_.scala.Option[Long] = _root_.scala.None
    var hashtagComment: _root_.scala.Option[Long] = _root_.scala.None
    var singleAsteriskComment: _root_.scala.Option[Long] = _root_.scala.None
    var docStringComment: _root_.scala.Option[Long] = _root_.scala.None
    var recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = _root_.scala.None
    var requiredField: String = null
    var _got_requiredField = false
    var constructionRequiredField: _root_.scala.Option[Long] = _root_.scala.None
    var anInt8: _root_.scala.Option[Byte] = _root_.scala.None
    var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
    var _done = false

    _iprot.readStructBegin()
    while (!_done) {
      val _field = _iprot.readFieldBegin()
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 =>
            _field.`type` match {
              case TType.LIST =>
                aList = readAListValue(_iprot)
              case _actualType =>
                val _expectedType = TType.LIST
                throw new TProtocolException(
                  "Received wrong type for field 'aList' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 2 =>
            _field.`type` match {
              case TType.SET =>
                aSet = readASetValue(_iprot)
              case _actualType =>
                val _expectedType = TType.SET
                throw new TProtocolException(
                  "Received wrong type for field 'aSet' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 3 =>
            _field.`type` match {
              case TType.MAP =>
                aMap = readAMapValue(_iprot)
              case _actualType =>
                val _expectedType = TType.MAP
                throw new TProtocolException(
                  "Received wrong type for field 'aMap' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 4 =>
            _field.`type` match {
              case TType.STRUCT =>
                aRequest = _root_.scala.Some(readARequestValue(_iprot))
              case _actualType =>
                val _expectedType = TType.STRUCT
                throw new TProtocolException(
                  "Received wrong type for field 'aRequest' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 5 =>
            _field.`type` match {
              case TType.LIST =>
                subRequests = readSubRequestsValue(_iprot)
              case _actualType =>
                val _expectedType = TType.LIST
                throw new TProtocolException(
                  "Received wrong type for field 'subRequests' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 6 =>
            _field.`type` match {
              case TType.STRING =>
                hasDefault = readHasDefaultValue(_iprot)
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'hasDefault' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 7 =>
            _field.`type` match {
              case TType.I64 =>
                noComment = _root_.scala.Some(readNoCommentValue(_iprot))
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'noComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 8 =>
            _field.`type` match {
              case TType.I64 =>
                doubleSlashComment = _root_.scala.Some(readDoubleSlashCommentValue(_iprot))
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'doubleSlashComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 9 =>
            _field.`type` match {
              case TType.I64 =>
                hashtagComment = _root_.scala.Some(readHashtagCommentValue(_iprot))
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'hashtagComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 10 =>
            _field.`type` match {
              case TType.I64 =>
                singleAsteriskComment = _root_.scala.Some(readSingleAsteriskCommentValue(_iprot))
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'singleAsteriskComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 11 =>
            _field.`type` match {
              case TType.I64 =>
                docStringComment = _root_.scala.Some(readDocStringCommentValue(_iprot))
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'docStringComment' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 12 =>
            _field.`type` match {
              case TType.STRUCT =>
                recRequest = _root_.scala.Some(readRecRequestValue(_iprot))
              case _actualType =>
                val _expectedType = TType.STRUCT
                throw new TProtocolException(
                  "Received wrong type for field 'recRequest' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 13 =>
            _field.`type` match {
              case TType.STRING =>
                requiredField = readRequiredFieldValue(_iprot)
                _got_requiredField = true
              case _actualType =>
                val _expectedType = TType.STRING
                throw new TProtocolException(
                  "Received wrong type for field 'requiredField' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 14 =>
            _field.`type` match {
              case TType.I64 =>
                constructionRequiredField = _root_.scala.Some(readConstructionRequiredFieldValue(_iprot))
              case _actualType =>
                val _expectedType = TType.I64
                throw new TProtocolException(
                  "Received wrong type for field 'constructionRequiredField' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case 15 =>
            _field.`type` match {
              case TType.BYTE =>
                anInt8 = _root_.scala.Some(readAnInt8Value(_iprot))
              case _actualType =>
                val _expectedType = TType.BYTE
                throw new TProtocolException(
                  "Received wrong type for field 'anInt8' (expected=%s, actual=%s).".format(
                    ttypeToString(_expectedType),
                    ttypeToString(_actualType)
                  )
                )
            }
          case _ =>
            if (_passthroughFields == null)
              _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
            _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()

    if (!_got_requiredField) throw new TProtocolException("Required field 'requiredField' was not found in serialized data for struct Request")
    new Immutable(
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefault,
      noComment,
      doubleSlashComment,
      hashtagComment,
      singleAsteriskComment,
      docStringComment,
      recRequest,
      requiredField,
      constructionRequiredField,
      anInt8,
      if (_passthroughFields == null)
        NoPassthroughFields
      else
        _passthroughFields.result()
    )
  }

  def apply(
    aList: _root_.scala.collection.Seq[String] = _root_.scala.collection.Seq[String](),
    aSet: _root_.scala.collection.Set[Int] = _root_.scala.collection.Set[Int](),
    aMap: _root_.scala.collection.Map[Long, Long] = _root_.scala.collection.Map[Long, Long](),
    aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = _root_.scala.None,
    subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request](),
    hasDefault: String = "the_default",
    noComment: _root_.scala.Option[Long] = _root_.scala.None,
    doubleSlashComment: _root_.scala.Option[Long] = _root_.scala.None,
    hashtagComment: _root_.scala.Option[Long] = _root_.scala.None,
    singleAsteriskComment: _root_.scala.Option[Long] = _root_.scala.None,
    docStringComment: _root_.scala.Option[Long] = _root_.scala.None,
    recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = _root_.scala.None,
    requiredField: String,
    constructionRequiredField: Long,
    anInt8: _root_.scala.Option[Byte] = _root_.scala.None
  ): Request =
    new Immutable(
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefault,
      noComment,
      doubleSlashComment,
      hashtagComment,
      singleAsteriskComment,
      docStringComment,
      recRequest,
      requiredField,
      constructionRequiredField,
      anInt8
    )

  def unapply(_item: Request): _root_.scala.Option[_root_.scala.Tuple15[_root_.scala.collection.Seq[String], _root_.scala.collection.Set[Int], _root_.scala.collection.Map[Long, Long], Option[com.twitter.scrooge.test.gold.thriftscala.Request], _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request], String, Option[Long], Option[Long], Option[Long], Option[Long], Option[Long], Option[com.twitter.scrooge.test.gold.thriftscala.Recursive], String, Option[Long], Option[Byte]]] = _root_.scala.Some(_item.toTuple)


  @inline private[thriftscala] def readAListValue(_iprot: TProtocol): _root_.scala.collection.Seq[String] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new _root_.scala.collection.mutable.ArrayBuffer[String](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          _iprot.readString()
        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  @inline private def writeAListField(aList_item: _root_.scala.collection.Seq[String], _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(AListField)
    writeAListValue(aList_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeAListValue(aList_item: _root_.scala.collection.Seq[String], _oprot: TProtocol): Unit = {
    _oprot.writeListBegin(new TList(TType.STRING, aList_item.size))
    aList_item match {
      case _: IndexedSeq[_] =>
        var _i = 0
        val _size = aList_item.size
        while (_i < _size) {
          val aList_item_element = aList_item(_i)
          _oprot.writeString(aList_item_element)
          _i += 1
        }
      case _ =>
        aList_item.foreach { aList_item_element =>
          _oprot.writeString(aList_item_element)
        }
    }
    _oprot.writeListEnd()
  }

  @inline private[thriftscala] def readASetValue(_iprot: TProtocol): _root_.scala.collection.Set[Int] = {
    val _set = _iprot.readSetBegin()
    if (_set.size == 0) {
      _iprot.readSetEnd()
      _root_.scala.collection.Set.empty[Int]
    } else {
      val _rv = new _root_.scala.collection.mutable.HashSet[Int]
      var _i = 0
      while (_i < _set.size) {
        _rv += {
          _iprot.readI32()
        }
        _i += 1
      }
      _iprot.readSetEnd()
      _rv
    }
  }

  @inline private def writeASetField(aSet_item: _root_.scala.collection.Set[Int], _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(ASetField)
    writeASetValue(aSet_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeASetValue(aSet_item: _root_.scala.collection.Set[Int], _oprot: TProtocol): Unit = {
    _oprot.writeSetBegin(new TSet(TType.I32, aSet_item.size))
    aSet_item.foreach { aSet_item_element =>
      _oprot.writeI32(aSet_item_element)
    }
    _oprot.writeSetEnd()
  }

  @inline private[thriftscala] def readAMapValue(_iprot: TProtocol): _root_.scala.collection.Map[Long, Long] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Long, Long]
    } else {
      val _rv = new _root_.scala.collection.mutable.HashMap[Long, Long]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          _iprot.readI64()
        }
        val _value = {
          _iprot.readI64()
        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  @inline private def writeAMapField(aMap_item: _root_.scala.collection.Map[Long, Long], _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(AMapField)
    writeAMapValue(aMap_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeAMapValue(aMap_item: _root_.scala.collection.Map[Long, Long], _oprot: TProtocol): Unit = {
    _oprot.writeMapBegin(new TMap(TType.I64, TType.I64, aMap_item.size))
    aMap_item.foreach { case (aMap_item_key, aMap_item_value) =>
      _oprot.writeI64(aMap_item_key)
      _oprot.writeI64(aMap_item_value)
    }
    _oprot.writeMapEnd()
  }

  @inline private[thriftscala] def readARequestValue(_iprot: TProtocol): com.twitter.scrooge.test.gold.thriftscala.Request = {
    com.twitter.scrooge.test.gold.thriftscala.Request.decode(_iprot)
  }

  @inline private def writeARequestField(aRequest_item: com.twitter.scrooge.test.gold.thriftscala.Request, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(ARequestField)
    writeARequestValue(aRequest_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeARequestValue(aRequest_item: com.twitter.scrooge.test.gold.thriftscala.Request, _oprot: TProtocol): Unit = {
    aRequest_item.write(_oprot)
  }

  @inline private[thriftscala] def readSubRequestsValue(_iprot: TProtocol): _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new _root_.scala.collection.mutable.ArrayBuffer[com.twitter.scrooge.test.gold.thriftscala.Request](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          com.twitter.scrooge.test.gold.thriftscala.Request.decode(_iprot)
        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  @inline private def writeSubRequestsField(subRequests_item: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request], _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(SubRequestsField)
    writeSubRequestsValue(subRequests_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeSubRequestsValue(subRequests_item: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request], _oprot: TProtocol): Unit = {
    _oprot.writeListBegin(new TList(TType.STRUCT, subRequests_item.size))
    subRequests_item match {
      case _: IndexedSeq[_] =>
        var _i = 0
        val _size = subRequests_item.size
        while (_i < _size) {
          val subRequests_item_element = subRequests_item(_i)
          subRequests_item_element.write(_oprot)
          _i += 1
        }
      case _ =>
        subRequests_item.foreach { subRequests_item_element =>
          subRequests_item_element.write(_oprot)
        }
    }
    _oprot.writeListEnd()
  }

  @inline private[thriftscala] def readHasDefaultValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writeHasDefaultField(hasDefault_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(HasDefaultField)
    writeHasDefaultValue(hasDefault_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeHasDefaultValue(hasDefault_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(hasDefault_item)
  }

  @inline private[thriftscala] def readNoCommentValue(_iprot: TProtocol): Long = {
    _iprot.readI64()
  }

  @inline private def writeNoCommentField(noComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(NoCommentField)
    writeNoCommentValue(noComment_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeNoCommentValue(noComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeI64(noComment_item)
  }

  @inline private[thriftscala] def readDoubleSlashCommentValue(_iprot: TProtocol): Long = {
    _iprot.readI64()
  }

  @inline private def writeDoubleSlashCommentField(doubleSlashComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(DoubleSlashCommentField)
    writeDoubleSlashCommentValue(doubleSlashComment_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeDoubleSlashCommentValue(doubleSlashComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeI64(doubleSlashComment_item)
  }

  @inline private[thriftscala] def readHashtagCommentValue(_iprot: TProtocol): Long = {
    _iprot.readI64()
  }

  @inline private def writeHashtagCommentField(hashtagComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(HashtagCommentField)
    writeHashtagCommentValue(hashtagComment_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeHashtagCommentValue(hashtagComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeI64(hashtagComment_item)
  }

  @inline private[thriftscala] def readSingleAsteriskCommentValue(_iprot: TProtocol): Long = {
    _iprot.readI64()
  }

  @inline private def writeSingleAsteriskCommentField(singleAsteriskComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(SingleAsteriskCommentField)
    writeSingleAsteriskCommentValue(singleAsteriskComment_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeSingleAsteriskCommentValue(singleAsteriskComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeI64(singleAsteriskComment_item)
  }

  @inline private[thriftscala] def readDocStringCommentValue(_iprot: TProtocol): Long = {
    _iprot.readI64()
  }

  @inline private def writeDocStringCommentField(docStringComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(DocStringCommentField)
    writeDocStringCommentValue(docStringComment_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeDocStringCommentValue(docStringComment_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeI64(docStringComment_item)
  }

  @inline private[thriftscala] def readRecRequestValue(_iprot: TProtocol): com.twitter.scrooge.test.gold.thriftscala.Recursive = {
    com.twitter.scrooge.test.gold.thriftscala.Recursive.decode(_iprot)
  }

  @inline private def writeRecRequestField(recRequest_item: com.twitter.scrooge.test.gold.thriftscala.Recursive, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(RecRequestField)
    writeRecRequestValue(recRequest_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeRecRequestValue(recRequest_item: com.twitter.scrooge.test.gold.thriftscala.Recursive, _oprot: TProtocol): Unit = {
    recRequest_item.write(_oprot)
  }

  @inline private[thriftscala] def readRequiredFieldValue(_iprot: TProtocol): String = {
    _iprot.readString()
  }

  @inline private def writeRequiredFieldField(requiredField_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(RequiredFieldField)
    writeRequiredFieldValue(requiredField_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeRequiredFieldValue(requiredField_item: String, _oprot: TProtocol): Unit = {
    _oprot.writeString(requiredField_item)
  }

  @inline private[thriftscala] def readConstructionRequiredFieldValue(_iprot: TProtocol): Long = {
    _iprot.readI64()
  }

  @inline private def writeConstructionRequiredFieldField(constructionRequiredField_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(ConstructionRequiredFieldField)
    writeConstructionRequiredFieldValue(constructionRequiredField_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeConstructionRequiredFieldValue(constructionRequiredField_item: Long, _oprot: TProtocol): Unit = {
    _oprot.writeI64(constructionRequiredField_item)
  }

  @inline private[thriftscala] def readAnInt8Value(_iprot: TProtocol): Byte = {
    _iprot.readByte()
  }

  @inline private def writeAnInt8Field(anInt8_item: Byte, _oprot: TProtocol): Unit = {
    _oprot.writeFieldBegin(AnInt8Field)
    writeAnInt8Value(anInt8_item, _oprot)
    _oprot.writeFieldEnd()
  }

  @inline private def writeAnInt8Value(anInt8_item: Byte, _oprot: TProtocol): Unit = {
    _oprot.writeByte(anInt8_item)
  }


  object Immutable extends ThriftStructCodec3[Request] {
    override def encode(_item: Request, _oproto: TProtocol): Unit = { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): Request = Request.decode(_iprot)
    override lazy val metaData: ThriftStructMetaData[Request] = Request.metaData
  }

  /**
   * The default read-only implementation of Request.  You typically should not need to
   * directly reference this class; instead, use the Request.apply method to construct
   * new instances.
   */
  class Immutable private[thriftscala](
      val aList: _root_.scala.collection.Seq[String],
      val aSet: _root_.scala.collection.Set[Int],
      val aMap: _root_.scala.collection.Map[Long, Long],
      val aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request],
      val subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request],
      val hasDefault: String,
      val noComment: _root_.scala.Option[Long],
      val doubleSlashComment: _root_.scala.Option[Long],
      val hashtagComment: _root_.scala.Option[Long],
      val singleAsteriskComment: _root_.scala.Option[Long],
      val docStringComment: _root_.scala.Option[Long],
      val recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive],
      val requiredField: String,
      val constructionRequiredField: _root_.scala.Option[Long],
      val anInt8: _root_.scala.Option[Byte],
      override val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends Request {
    private[thriftscala] def this(
      aList: _root_.scala.collection.Seq[String],
      aSet: _root_.scala.collection.Set[Int],
      aMap: _root_.scala.collection.Map[Long, Long],
      aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request],
      subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request],
      hasDefault: String,
      noComment: _root_.scala.Option[Long],
      doubleSlashComment: _root_.scala.Option[Long],
      hashtagComment: _root_.scala.Option[Long],
      singleAsteriskComment: _root_.scala.Option[Long],
      docStringComment: _root_.scala.Option[Long],
      recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive],
      requiredField: String,
      constructionRequiredField: _root_.scala.Option[Long],
      anInt8: _root_.scala.Option[Byte]
    ) = this(
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefault,
      noComment,
      doubleSlashComment,
      hashtagComment,
      singleAsteriskComment,
      docStringComment,
      recRequest,
      requiredField,
      constructionRequiredField,
      anInt8,
      Map.empty[Short, TFieldBlob]
    )
  def this(
      aList: _root_.scala.collection.Seq[String] = _root_.scala.collection.Seq[String](),
      aSet: _root_.scala.collection.Set[Int] = _root_.scala.collection.Set[Int](),
      aMap: _root_.scala.collection.Map[Long, Long] = _root_.scala.collection.Map[Long, Long](),
      aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = _root_.scala.None,
      subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request](),
      hasDefault: String = "the_default",
      noComment: _root_.scala.Option[Long] = _root_.scala.None,
      doubleSlashComment: _root_.scala.Option[Long] = _root_.scala.None,
      hashtagComment: _root_.scala.Option[Long] = _root_.scala.None,
      singleAsteriskComment: _root_.scala.Option[Long] = _root_.scala.None,
      docStringComment: _root_.scala.Option[Long] = _root_.scala.None,
      recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = _root_.scala.None,
      requiredField: String,
      constructionRequiredField: Long,
      anInt8: _root_.scala.Option[Byte] = _root_.scala.None
    ) = this(
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefault,
      noComment,
      doubleSlashComment,
      hashtagComment,
      singleAsteriskComment,
      docStringComment,
      recRequest,
      requiredField,
      Some(constructionRequiredField),
      anInt8,
      Map.empty[Short, TFieldBlob]
    )
  def this(
      aList: _root_.scala.collection.Seq[String],
      aSet: _root_.scala.collection.Set[Int],
      aMap: _root_.scala.collection.Map[Long, Long],
      aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request],
      subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request],
      hasDefault: String,
      noComment: _root_.scala.Option[Long],
      doubleSlashComment: _root_.scala.Option[Long],
      hashtagComment: _root_.scala.Option[Long],
      singleAsteriskComment: _root_.scala.Option[Long],
      docStringComment: _root_.scala.Option[Long],
      recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive],
      requiredField: String,
      constructionRequiredField: Long,
      anInt8: _root_.scala.Option[Byte],
      _passthroughFields: immutable$Map[Short, TFieldBlob]
  ) = this(
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefault,
      noComment,
      doubleSlashComment,
      hashtagComment,
      singleAsteriskComment,
      docStringComment,
      recRequest,
      requiredField,
      Some(constructionRequiredField),
      anInt8,
      _passthroughFields
  )
  }

  /**
   * This is another Immutable, this however keeps strings as lazy values that are lazily decoded from the backing
   * array byte on read.
   */
  private[this] class LazyImmutable(
      _proto: LazyTProtocol,
      _buf: Array[Byte],
      _start_offset: Int,
      _end_offset: Int,
      val aList: _root_.scala.collection.Seq[String],
      val aSet: _root_.scala.collection.Set[Int],
      val aMap: _root_.scala.collection.Map[Long, Long],
      val aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request],
      val subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request],
      hasDefaultOffset: Int,
      noCommentOffset: Int,
      doubleSlashCommentOffset: Int,
      hashtagCommentOffset: Int,
      singleAsteriskCommentOffset: Int,
      docStringCommentOffset: Int,
      val recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive],
      requiredFieldOffset: Int,
      constructionRequiredFieldOffset: Int,
      anInt8Offset: Int,
      override val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends Request {

    override def write(_oprot: TProtocol): Unit = {
      _oprot match {
        case i: LazyTProtocol => i.writeRaw(_buf, _start_offset, _end_offset - _start_offset)
        case _ => super.write(_oprot)
      }
    }

    lazy val hasDefault: String =
      if (hasDefaultOffset == -1)
        "the_default"
      else {
        _proto.decodeString(_buf, hasDefaultOffset)
      }
    lazy val noComment: _root_.scala.Option[Long] =
      if (noCommentOffset == -1)
        None
      else {
        Some(_proto.decodeI64(_buf, noCommentOffset))
      }
    lazy val doubleSlashComment: _root_.scala.Option[Long] =
      if (doubleSlashCommentOffset == -1)
        None
      else {
        Some(_proto.decodeI64(_buf, doubleSlashCommentOffset))
      }
    lazy val hashtagComment: _root_.scala.Option[Long] =
      if (hashtagCommentOffset == -1)
        None
      else {
        Some(_proto.decodeI64(_buf, hashtagCommentOffset))
      }
    lazy val singleAsteriskComment: _root_.scala.Option[Long] =
      if (singleAsteriskCommentOffset == -1)
        None
      else {
        Some(_proto.decodeI64(_buf, singleAsteriskCommentOffset))
      }
    lazy val docStringComment: _root_.scala.Option[Long] =
      if (docStringCommentOffset == -1)
        None
      else {
        Some(_proto.decodeI64(_buf, docStringCommentOffset))
      }
    lazy val requiredField: String =
      if (requiredFieldOffset == -1)
        null
      else {
        _proto.decodeString(_buf, requiredFieldOffset)
      }
    lazy val constructionRequiredField: _root_.scala.Option[Long] =
      if (constructionRequiredFieldOffset == -1)
        None
      else {
        Some(_proto.decodeI64(_buf, constructionRequiredFieldOffset))
      }
    lazy val anInt8: _root_.scala.Option[Byte] =
      if (anInt8Offset == -1)
        None
      else {
        Some(_proto.decodeByte(_buf, anInt8Offset))
      }

    /**
     * Override the super hash code to make it a lazy val rather than def.
     *
     * Calculating the hash code can be expensive, caching it where possible
     * can provide significant performance wins. (Key in a hash map for instance)
     * Usually not safe since the normal constructor will accept a mutable map or
     * set as an arg
     * Here however we control how the class is generated from serialized data.
     * With the class private and the contract that we throw away our mutable references
     * having the hash code lazy here is safe.
     */
    override lazy val hashCode = super.hashCode
  }

  /**
   * This Proxy trait allows you to extend the Request trait with additional state or
   * behavior and implement the read-only methods from Request using an underlying
   * instance.
   */
  trait Proxy extends Request {
    protected def _underlying_Request: Request
    override def aList: _root_.scala.collection.Seq[String] = _underlying_Request.aList
    override def aSet: _root_.scala.collection.Set[Int] = _underlying_Request.aSet
    override def aMap: _root_.scala.collection.Map[Long, Long] = _underlying_Request.aMap
    override def aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = _underlying_Request.aRequest
    override def subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = _underlying_Request.subRequests
    override def hasDefault: String = _underlying_Request.hasDefault
    override def noComment: _root_.scala.Option[Long] = _underlying_Request.noComment
    override def doubleSlashComment: _root_.scala.Option[Long] = _underlying_Request.doubleSlashComment
    override def hashtagComment: _root_.scala.Option[Long] = _underlying_Request.hashtagComment
    override def singleAsteriskComment: _root_.scala.Option[Long] = _underlying_Request.singleAsteriskComment
    override def docStringComment: _root_.scala.Option[Long] = _underlying_Request.docStringComment
    override def recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = _underlying_Request.recRequest
    override def requiredField: String = _underlying_Request.requiredField
    override def constructionRequiredField: _root_.scala.Option[Long] = _underlying_Request.constructionRequiredField
    override def anInt8: _root_.scala.Option[Byte] = _underlying_Request.anInt8
    override def _passthroughFields: immutable$Map[Short, TFieldBlob] = _underlying_Request._passthroughFields
  }
}

/**
 * Prefer the companion object's [[com.twitter.scrooge.test.gold.thriftscala.Request.apply]]
 * for construction if you don't need to specify passthrough fields.
 */
trait Request
  extends ThriftStruct
  with _root_.scala.Product15[_root_.scala.collection.Seq[String], _root_.scala.collection.Set[Int], _root_.scala.collection.Map[Long, Long], Option[com.twitter.scrooge.test.gold.thriftscala.Request], _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request], String, Option[Long], Option[Long], Option[Long], Option[Long], Option[Long], Option[com.twitter.scrooge.test.gold.thriftscala.Recursive], String, Option[Long], Option[Byte]]
  with ValidatingThriftStruct[Request]
  with java.io.Serializable
{
  import Request._

  def aList: _root_.scala.collection.Seq[String]
  def aSet: _root_.scala.collection.Set[Int]
  def aMap: _root_.scala.collection.Map[Long, Long]
  def aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request]
  def subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request]
  def hasDefault: String
  def noComment: _root_.scala.Option[Long]
  def doubleSlashComment: _root_.scala.Option[Long]
  def hashtagComment: _root_.scala.Option[Long]
  def singleAsteriskComment: _root_.scala.Option[Long]
  /**
   * docstring comment
   */
  def docStringComment: _root_.scala.Option[Long]
  /**
   * recursive value
   */
  def recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive]
  def requiredField: String
  def constructionRequiredField: _root_.scala.Option[Long]
  def anInt8: _root_.scala.Option[Byte]

  def _passthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty

  def _1: _root_.scala.collection.Seq[String] = aList
  def _2: _root_.scala.collection.Set[Int] = aSet
  def _3: _root_.scala.collection.Map[Long, Long] = aMap
  def _4: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = aRequest
  def _5: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = subRequests
  def _6: String = hasDefault
  def _7: _root_.scala.Option[Long] = noComment
  def _8: _root_.scala.Option[Long] = doubleSlashComment
  def _9: _root_.scala.Option[Long] = hashtagComment
  def _10: _root_.scala.Option[Long] = singleAsteriskComment
  def _11: _root_.scala.Option[Long] = docStringComment
  def _12: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = recRequest
  def _13: String = requiredField
  def _14: _root_.scala.Option[Long] = constructionRequiredField
  def _15: _root_.scala.Option[Byte] = anInt8

  def toTuple: _root_.scala.Tuple15[_root_.scala.collection.Seq[String], _root_.scala.collection.Set[Int], _root_.scala.collection.Map[Long, Long], Option[com.twitter.scrooge.test.gold.thriftscala.Request], _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request], String, Option[Long], Option[Long], Option[Long], Option[Long], Option[Long], Option[com.twitter.scrooge.test.gold.thriftscala.Recursive], String, Option[Long], Option[Byte]] = {
    (
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefault,
      noComment,
      doubleSlashComment,
      hashtagComment,
      singleAsteriskComment,
      docStringComment,
      recRequest,
      requiredField,
      constructionRequiredField,
      anInt8
    )
  }


  /**
   * Gets a field value encoded as a binary blob using TCompactProtocol.  If the specified field
   * is present in the passthrough map, that value is returned.  Otherwise, if the specified field
   * is known and not optional and set to None, then the field is serialized and returned.
   */
  def getFieldBlob(_fieldId: Short): _root_.scala.Option[TFieldBlob] = {
    lazy val _buff = new TMemoryBuffer(32)
    lazy val _oprot = new TCompactProtocol(_buff)
    _passthroughFields.get(_fieldId) match {
      case blob: _root_.scala.Some[TFieldBlob] => blob
      case _root_.scala.None => {
        val _fieldOpt: _root_.scala.Option[TField] =
          _fieldId match {
            case 1 =>
              if (aList ne null) {
                writeAListValue(aList, _oprot)
                _root_.scala.Some(Request.AListField)
              } else {
                _root_.scala.None
              }
            case 2 =>
              if (aSet ne null) {
                writeASetValue(aSet, _oprot)
                _root_.scala.Some(Request.ASetField)
              } else {
                _root_.scala.None
              }
            case 3 =>
              if (aMap ne null) {
                writeAMapValue(aMap, _oprot)
                _root_.scala.Some(Request.AMapField)
              } else {
                _root_.scala.None
              }
            case 4 =>
              if (aRequest.isDefined) {
                writeARequestValue(aRequest.get, _oprot)
                _root_.scala.Some(Request.ARequestField)
              } else {
                _root_.scala.None
              }
            case 5 =>
              if (subRequests ne null) {
                writeSubRequestsValue(subRequests, _oprot)
                _root_.scala.Some(Request.SubRequestsField)
              } else {
                _root_.scala.None
              }
            case 6 =>
              if (hasDefault ne null) {
                writeHasDefaultValue(hasDefault, _oprot)
                _root_.scala.Some(Request.HasDefaultField)
              } else {
                _root_.scala.None
              }
            case 7 =>
              if (noComment.isDefined) {
                writeNoCommentValue(noComment.get, _oprot)
                _root_.scala.Some(Request.NoCommentField)
              } else {
                _root_.scala.None
              }
            case 8 =>
              if (doubleSlashComment.isDefined) {
                writeDoubleSlashCommentValue(doubleSlashComment.get, _oprot)
                _root_.scala.Some(Request.DoubleSlashCommentField)
              } else {
                _root_.scala.None
              }
            case 9 =>
              if (hashtagComment.isDefined) {
                writeHashtagCommentValue(hashtagComment.get, _oprot)
                _root_.scala.Some(Request.HashtagCommentField)
              } else {
                _root_.scala.None
              }
            case 10 =>
              if (singleAsteriskComment.isDefined) {
                writeSingleAsteriskCommentValue(singleAsteriskComment.get, _oprot)
                _root_.scala.Some(Request.SingleAsteriskCommentField)
              } else {
                _root_.scala.None
              }
            case 11 =>
              if (docStringComment.isDefined) {
                writeDocStringCommentValue(docStringComment.get, _oprot)
                _root_.scala.Some(Request.DocStringCommentField)
              } else {
                _root_.scala.None
              }
            case 12 =>
              if (recRequest.isDefined) {
                writeRecRequestValue(recRequest.get, _oprot)
                _root_.scala.Some(Request.RecRequestField)
              } else {
                _root_.scala.None
              }
            case 13 =>
              if (requiredField ne null) {
                writeRequiredFieldValue(requiredField, _oprot)
                _root_.scala.Some(Request.RequiredFieldField)
              } else {
                _root_.scala.None
              }
            case 14 =>
              if (constructionRequiredField.isDefined) {
                writeConstructionRequiredFieldValue(constructionRequiredField.get, _oprot)
                _root_.scala.Some(Request.ConstructionRequiredFieldField)
              } else {
                _root_.scala.None
              }
            case 15 =>
              if (anInt8.isDefined) {
                writeAnInt8Value(anInt8.get, _oprot)
                _root_.scala.Some(Request.AnInt8Field)
              } else {
                _root_.scala.None
              }
            case _ => _root_.scala.None
          }
        _fieldOpt match {
          case _root_.scala.Some(_field) =>
            _root_.scala.Some(TFieldBlob(_field, Buf.ByteArray.Owned(_buff.getArray())))
          case _root_.scala.None =>
            _root_.scala.None
        }
      }
    }
  }

  /**
   * Collects TCompactProtocol-encoded field values according to `getFieldBlob` into a map.
   */
  def getFieldBlobs(ids: TraversableOnce[Short]): immutable$Map[Short, TFieldBlob] =
    (ids flatMap { id => getFieldBlob(id) map { id -> _ } }).toMap

  /**
   * Sets a field using a TCompactProtocol-encoded binary blob.  If the field is a known
   * field, the blob is decoded and the field is set to the decoded value.  If the field
   * is unknown and passthrough fields are enabled, then the blob will be stored in
   * _passthroughFields.
   */
  def setField(_blob: TFieldBlob): Request = {
    var aList: _root_.scala.collection.Seq[String] = this.aList
    var aSet: _root_.scala.collection.Set[Int] = this.aSet
    var aMap: _root_.scala.collection.Map[Long, Long] = this.aMap
    var aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = this.aRequest
    var subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = this.subRequests
    var hasDefault: String = this.hasDefault
    var noComment: _root_.scala.Option[Long] = this.noComment
    var doubleSlashComment: _root_.scala.Option[Long] = this.doubleSlashComment
    var hashtagComment: _root_.scala.Option[Long] = this.hashtagComment
    var singleAsteriskComment: _root_.scala.Option[Long] = this.singleAsteriskComment
    var docStringComment: _root_.scala.Option[Long] = this.docStringComment
    var recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = this.recRequest
    var requiredField: String = this.requiredField
    var constructionRequiredField: _root_.scala.Option[Long] = this.constructionRequiredField
    var anInt8: _root_.scala.Option[Byte] = this.anInt8
    var _passthroughFields = this._passthroughFields
    _blob.id match {
      case 1 =>
        aList = readAListValue(_blob.read)
      case 2 =>
        aSet = readASetValue(_blob.read)
      case 3 =>
        aMap = readAMapValue(_blob.read)
      case 4 =>
        aRequest = _root_.scala.Some(readARequestValue(_blob.read))
      case 5 =>
        subRequests = readSubRequestsValue(_blob.read)
      case 6 =>
        hasDefault = readHasDefaultValue(_blob.read)
      case 7 =>
        noComment = _root_.scala.Some(readNoCommentValue(_blob.read))
      case 8 =>
        doubleSlashComment = _root_.scala.Some(readDoubleSlashCommentValue(_blob.read))
      case 9 =>
        hashtagComment = _root_.scala.Some(readHashtagCommentValue(_blob.read))
      case 10 =>
        singleAsteriskComment = _root_.scala.Some(readSingleAsteriskCommentValue(_blob.read))
      case 11 =>
        docStringComment = _root_.scala.Some(readDocStringCommentValue(_blob.read))
      case 12 =>
        recRequest = _root_.scala.Some(readRecRequestValue(_blob.read))
      case 13 =>
        requiredField = readRequiredFieldValue(_blob.read)
      case 14 =>
        constructionRequiredField = _root_.scala.Some(readConstructionRequiredFieldValue(_blob.read))
      case 15 =>
        anInt8 = _root_.scala.Some(readAnInt8Value(_blob.read))
      case _ => _passthroughFields += (_blob.id -> _blob)
    }
    new Immutable(
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefault,
      noComment,
      doubleSlashComment,
      hashtagComment,
      singleAsteriskComment,
      docStringComment,
      recRequest,
      requiredField,
      constructionRequiredField,
      anInt8,
      _passthroughFields
    )
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is removed
   * from the passthroughFields map, if present.
   */
  def unsetField(_fieldId: Short): Request = {
    var aList: _root_.scala.collection.Seq[String] = this.aList
    var aSet: _root_.scala.collection.Set[Int] = this.aSet
    var aMap: _root_.scala.collection.Map[Long, Long] = this.aMap
    var aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = this.aRequest
    var subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = this.subRequests
    var hasDefault: String = this.hasDefault
    var noComment: _root_.scala.Option[Long] = this.noComment
    var doubleSlashComment: _root_.scala.Option[Long] = this.doubleSlashComment
    var hashtagComment: _root_.scala.Option[Long] = this.hashtagComment
    var singleAsteriskComment: _root_.scala.Option[Long] = this.singleAsteriskComment
    var docStringComment: _root_.scala.Option[Long] = this.docStringComment
    var recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = this.recRequest
    var requiredField: String = this.requiredField
    var constructionRequiredField: _root_.scala.Option[Long] = this.constructionRequiredField
    var anInt8: _root_.scala.Option[Byte] = this.anInt8

    _fieldId match {
      case 1 =>
        aList = _root_.scala.collection.Seq[String]()
      case 2 =>
        aSet = _root_.scala.collection.Set[Int]()
      case 3 =>
        aMap = _root_.scala.collection.Map[Long, Long]()
      case 4 =>
        aRequest = _root_.scala.None
      case 5 =>
        subRequests = _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request]()
      case 6 =>
        hasDefault = "the_default"
      case 7 =>
        noComment = _root_.scala.None
      case 8 =>
        doubleSlashComment = _root_.scala.None
      case 9 =>
        hashtagComment = _root_.scala.None
      case 10 =>
        singleAsteriskComment = _root_.scala.None
      case 11 =>
        docStringComment = _root_.scala.None
      case 12 =>
        recRequest = _root_.scala.None
      case 13 =>
        requiredField = null
      case 14 =>
        constructionRequiredField = _root_.scala.None
      case 15 =>
        anInt8 = _root_.scala.None
      case _ =>
    }
    new Immutable(
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefault,
      noComment,
      doubleSlashComment,
      hashtagComment,
      singleAsteriskComment,
      docStringComment,
      recRequest,
      requiredField,
      constructionRequiredField,
      anInt8,
      _passthroughFields - _fieldId
    )
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is removed
   * from the passthroughFields map, if present.
   */
  def unsetAList: Request = unsetField(1)

  def unsetASet: Request = unsetField(2)

  def unsetAMap: Request = unsetField(3)

  def unsetARequest: Request = unsetField(4)

  def unsetSubRequests: Request = unsetField(5)

  def unsetHasDefault: Request = unsetField(6)

  def unsetNoComment: Request = unsetField(7)

  def unsetDoubleSlashComment: Request = unsetField(8)

  def unsetHashtagComment: Request = unsetField(9)

  def unsetSingleAsteriskComment: Request = unsetField(10)

  def unsetDocStringComment: Request = unsetField(11)

  def unsetRecRequest: Request = unsetField(12)

  def unsetRequiredField: Request = unsetField(13)

  def unsetConstructionRequiredField: Request = unsetField(14)

  def unsetAnInt8: Request = unsetField(15)


  override def write(_oprot: TProtocol): Unit = {
    Request.validate(this)
    _oprot.writeStructBegin(Struct)
    if (aList ne null) writeAListField(aList, _oprot)
    if (aSet ne null) writeASetField(aSet, _oprot)
    if (aMap ne null) writeAMapField(aMap, _oprot)
    if (aRequest.isDefined) writeARequestField(aRequest.get, _oprot)
    if (subRequests ne null) writeSubRequestsField(subRequests, _oprot)
    if (hasDefault ne null) writeHasDefaultField(hasDefault, _oprot)
    if (noComment.isDefined) writeNoCommentField(noComment.get, _oprot)
    if (doubleSlashComment.isDefined) writeDoubleSlashCommentField(doubleSlashComment.get, _oprot)
    if (hashtagComment.isDefined) writeHashtagCommentField(hashtagComment.get, _oprot)
    if (singleAsteriskComment.isDefined) writeSingleAsteriskCommentField(singleAsteriskComment.get, _oprot)
    if (docStringComment.isDefined) writeDocStringCommentField(docStringComment.get, _oprot)
    if (recRequest.isDefined) writeRecRequestField(recRequest.get, _oprot)
    if (requiredField ne null) writeRequiredFieldField(requiredField, _oprot)
    if (constructionRequiredField.isDefined) writeConstructionRequiredFieldField(constructionRequiredField.get, _oprot)
    if (anInt8.isDefined) writeAnInt8Field(anInt8.get, _oprot)
    if (_passthroughFields.nonEmpty) {
      _passthroughFields.values.foreach { _.write(_oprot) }
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    aList: _root_.scala.collection.Seq[String] = this.aList,
    aSet: _root_.scala.collection.Set[Int] = this.aSet,
    aMap: _root_.scala.collection.Map[Long, Long] = this.aMap,
    aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = this.aRequest,
    subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = this.subRequests,
    hasDefault: String = this.hasDefault,
    noComment: _root_.scala.Option[Long] = this.noComment,
    doubleSlashComment: _root_.scala.Option[Long] = this.doubleSlashComment,
    hashtagComment: _root_.scala.Option[Long] = this.hashtagComment,
    singleAsteriskComment: _root_.scala.Option[Long] = this.singleAsteriskComment,
    docStringComment: _root_.scala.Option[Long] = this.docStringComment,
    recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = this.recRequest,
    requiredField: String = this.requiredField,
    anInt8: _root_.scala.Option[Byte] = this.anInt8,
    _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
  ): Request =
    new Immutable(
      aList,
      aSet,
      aMap,
      aRequest,
      subRequests,
      hasDefault,
      noComment,
      doubleSlashComment,
      hashtagComment,
      singleAsteriskComment,
      docStringComment,
      recRequest,
      requiredField,
      this.constructionRequiredField,
      anInt8,
      _passthroughFields
    )

  /**
   * Construction required fields need a different copy API than all the other fields. If a Some
   * argument is provided, then that value will change. None arguments mean that there is no change
   * to the field.
   */
  def copyChangingConstructionRequiredFields(
    constructionRequiredField: _root_.scala.Option[Long] = None,
    _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
  ): Request =
    new Immutable(
      this.aList,
      this.aSet,
      this.aMap,
      this.aRequest,
      this.subRequests,
      this.hasDefault,
      this.noComment,
      this.doubleSlashComment,
      this.hashtagComment,
      this.singleAsteriskComment,
      this.docStringComment,
      this.recRequest,
      this.requiredField,
      constructionRequiredField.orElse(this.constructionRequiredField),
      this.anInt8,
      _passthroughFields
    )

  override def canEqual(other: Any): Boolean = other.isInstanceOf[Request]

  private def _equals(x: Request, y: Request): Boolean =
      x.productArity == y.productArity &&
      x.productIterator.sameElements(y.productIterator) &&
      x._passthroughFields == y._passthroughFields

  override def equals(other: Any): Boolean =
    canEqual(other) &&
      _equals(this, other.asInstanceOf[Request])

  override def hashCode: Int = {
    _root_.scala.runtime.ScalaRunTime._hashCode(this)
  }

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)


  override def productArity: Int = 15

  override def productElement(n: Int): Any = n match {
    case 0 => this.aList
    case 1 => this.aSet
    case 2 => this.aMap
    case 3 => this.aRequest
    case 4 => this.subRequests
    case 5 => this.hasDefault
    case 6 => this.noComment
    case 7 => this.doubleSlashComment
    case 8 => this.hashtagComment
    case 9 => this.singleAsteriskComment
    case 10 => this.docStringComment
    case 11 => this.recRequest
    case 12 => this.requiredField
    case 13 => this.constructionRequiredField
    case 14 => this.anInt8
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "Request"

  def _codec: ValidatingThriftStructCodec3[Request] = Request
}

private class Request__AdaptDecoder {

  def decode(_iprot: AdaptTProtocol): Request = {
    var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
    var _done = false
    val _start_offset = _iprot.offset

    val adapt = new Request__Adapt(
      _iprot,
      _iprot.buffer,
      _start_offset)

    AdaptTProtocol.usedStartMarker(1)
    var aList: _root_.scala.collection.Seq[String] = _root_.scala.collection.Seq[String]()

    adapt.set_aList(aList)
    AdaptTProtocol.usedEndMarker(1)

    AdaptTProtocol.usedStartMarker(2)
    var aSet: _root_.scala.collection.Set[Int] = _root_.scala.collection.Set[Int]()

    adapt.set_aSet(aSet)
    AdaptTProtocol.usedEndMarker(2)

    AdaptTProtocol.usedStartMarker(3)
    var aMap: _root_.scala.collection.Map[Long, Long] = _root_.scala.collection.Map[Long, Long]()

    adapt.set_aMap(aMap)
    AdaptTProtocol.usedEndMarker(3)

    AdaptTProtocol.usedStartMarker(4)
    var aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = _root_.scala.None

    adapt.set_aRequest(aRequest)
    AdaptTProtocol.usedEndMarker(4)

    AdaptTProtocol.usedStartMarker(5)
    var subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request]()

    adapt.set_subRequests(subRequests)
    AdaptTProtocol.usedEndMarker(5)

    AdaptTProtocol.usedStartMarker(6)
    var hasDefault: String = "the_default"

    adapt.set_hasDefault(hasDefault)
    AdaptTProtocol.usedEndMarker(6)

    AdaptTProtocol.usedStartMarker(7)
    var noComment: _root_.scala.Option[Long] = _root_.scala.None

    adapt.set_noComment(noComment)
    AdaptTProtocol.usedEndMarker(7)

    AdaptTProtocol.usedStartMarker(8)
    var doubleSlashComment: _root_.scala.Option[Long] = _root_.scala.None

    adapt.set_doubleSlashComment(doubleSlashComment)
    AdaptTProtocol.usedEndMarker(8)

    AdaptTProtocol.usedStartMarker(9)
    var hashtagComment: _root_.scala.Option[Long] = _root_.scala.None

    adapt.set_hashtagComment(hashtagComment)
    AdaptTProtocol.usedEndMarker(9)

    AdaptTProtocol.usedStartMarker(10)
    var singleAsteriskComment: _root_.scala.Option[Long] = _root_.scala.None

    adapt.set_singleAsteriskComment(singleAsteriskComment)
    AdaptTProtocol.usedEndMarker(10)

    AdaptTProtocol.usedStartMarker(11)
    var docStringComment: _root_.scala.Option[Long] = _root_.scala.None

    adapt.set_docStringComment(docStringComment)
    AdaptTProtocol.usedEndMarker(11)

    AdaptTProtocol.usedStartMarker(12)
    var recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = _root_.scala.None

    adapt.set_recRequest(recRequest)
    AdaptTProtocol.usedEndMarker(12)

    var _got_requiredField = false
    AdaptTProtocol.usedStartMarker(13)
    var requiredField: String = null
    AdaptTProtocol.usedEndMarker(13)

    AdaptTProtocol.usedStartMarker(14)
    var constructionRequiredField: _root_.scala.Option[Long] = _root_.scala.None

    adapt.set_constructionRequiredField(constructionRequiredField)
    AdaptTProtocol.usedEndMarker(14)

    AdaptTProtocol.usedStartMarker(15)
    var anInt8: _root_.scala.Option[Byte] = _root_.scala.None

    adapt.set_anInt8(anInt8)
    AdaptTProtocol.usedEndMarker(15)

    _iprot.readStructBegin()
    while (!_done) {
      val _field = _iprot.readFieldBegin()
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 => {
            _field.`type` match {
              case TType.LIST =>
                AdaptTProtocol.usedStartMarker(1)
                aList = Request.readAListValue(_iprot)
                AdaptTProtocol.usedEndMarker(1)
                AdaptTProtocol.unusedStartMarker(1)
                _iprot.offsetSkipList()
                AdaptTProtocol.unusedEndMarker(1)
              case _actualType =>
                val _expectedType = TType.LIST
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "aList")
            }
            AdaptTProtocol.usedStartMarker(1)
            adapt.set_aList(aList)
            AdaptTProtocol.usedEndMarker(1)
          }
          case 2 => {
            _field.`type` match {
              case TType.SET =>
                AdaptTProtocol.usedStartMarker(2)
                aSet = Request.readASetValue(_iprot)
                AdaptTProtocol.usedEndMarker(2)
                AdaptTProtocol.unusedStartMarker(2)
                _iprot.offsetSkipSet()
                AdaptTProtocol.unusedEndMarker(2)
              case _actualType =>
                val _expectedType = TType.SET
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "aSet")
            }
            AdaptTProtocol.usedStartMarker(2)
            adapt.set_aSet(aSet)
            AdaptTProtocol.usedEndMarker(2)
          }
          case 3 => {
            _field.`type` match {
              case TType.MAP =>
                AdaptTProtocol.usedStartMarker(3)
                aMap = Request.readAMapValue(_iprot)
                AdaptTProtocol.usedEndMarker(3)
                AdaptTProtocol.unusedStartMarker(3)
                _iprot.offsetSkipMap()
                AdaptTProtocol.unusedEndMarker(3)
              case _actualType =>
                val _expectedType = TType.MAP
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "aMap")
            }
            AdaptTProtocol.usedStartMarker(3)
            adapt.set_aMap(aMap)
            AdaptTProtocol.usedEndMarker(3)
          }
          case 4 => {
            _field.`type` match {
              case TType.STRUCT =>
                AdaptTProtocol.usedStartMarker(4)
                aRequest = _root_.scala.Some(Request.readARequestValue(_iprot))
                AdaptTProtocol.usedEndMarker(4)
                AdaptTProtocol.unusedStartMarker(4)
                _iprot.offsetSkipStruct()
                AdaptTProtocol.unusedEndMarker(4)
              case _actualType =>
                val _expectedType = TType.STRUCT
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "aRequest")
            }
            AdaptTProtocol.usedStartMarker(4)
            adapt.set_aRequest(aRequest)
            AdaptTProtocol.usedEndMarker(4)
          }
          case 5 => {
            _field.`type` match {
              case TType.LIST =>
                AdaptTProtocol.usedStartMarker(5)
                subRequests = Request.readSubRequestsValue(_iprot)
                AdaptTProtocol.usedEndMarker(5)
                AdaptTProtocol.unusedStartMarker(5)
                _iprot.offsetSkipList()
                AdaptTProtocol.unusedEndMarker(5)
              case _actualType =>
                val _expectedType = TType.LIST
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "subRequests")
            }
            AdaptTProtocol.usedStartMarker(5)
            adapt.set_subRequests(subRequests)
            AdaptTProtocol.usedEndMarker(5)
          }
          case 6 => {
            _field.`type` match {
              case TType.STRING =>
                AdaptTProtocol.usedStartMarker(6)
                hasDefault = Request.readHasDefaultValue(_iprot)
                AdaptTProtocol.usedEndMarker(6)
                AdaptTProtocol.unusedStartMarker(6)
                _iprot.offsetSkipString()
                AdaptTProtocol.unusedEndMarker(6)
              case _actualType =>
                val _expectedType = TType.STRING
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "hasDefault")
            }
            AdaptTProtocol.usedStartMarker(6)
            adapt.set_hasDefault(hasDefault)
            AdaptTProtocol.usedEndMarker(6)
          }
          case 7 => {
            _field.`type` match {
              case TType.I64 =>
                AdaptTProtocol.usedStartMarker(7)
                noComment = _root_.scala.Some(Request.readNoCommentValue(_iprot))
                AdaptTProtocol.usedEndMarker(7)
                AdaptTProtocol.unusedStartMarker(7)
                _iprot.offsetSkipI64()
                AdaptTProtocol.unusedEndMarker(7)
              case _actualType =>
                val _expectedType = TType.I64
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "noComment")
            }
            AdaptTProtocol.usedStartMarker(7)
            adapt.set_noComment(noComment)
            AdaptTProtocol.usedEndMarker(7)
          }
          case 8 => {
            _field.`type` match {
              case TType.I64 =>
                AdaptTProtocol.usedStartMarker(8)
                doubleSlashComment = _root_.scala.Some(Request.readDoubleSlashCommentValue(_iprot))
                AdaptTProtocol.usedEndMarker(8)
                AdaptTProtocol.unusedStartMarker(8)
                _iprot.offsetSkipI64()
                AdaptTProtocol.unusedEndMarker(8)
              case _actualType =>
                val _expectedType = TType.I64
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "doubleSlashComment")
            }
            AdaptTProtocol.usedStartMarker(8)
            adapt.set_doubleSlashComment(doubleSlashComment)
            AdaptTProtocol.usedEndMarker(8)
          }
          case 9 => {
            _field.`type` match {
              case TType.I64 =>
                AdaptTProtocol.usedStartMarker(9)
                hashtagComment = _root_.scala.Some(Request.readHashtagCommentValue(_iprot))
                AdaptTProtocol.usedEndMarker(9)
                AdaptTProtocol.unusedStartMarker(9)
                _iprot.offsetSkipI64()
                AdaptTProtocol.unusedEndMarker(9)
              case _actualType =>
                val _expectedType = TType.I64
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "hashtagComment")
            }
            AdaptTProtocol.usedStartMarker(9)
            adapt.set_hashtagComment(hashtagComment)
            AdaptTProtocol.usedEndMarker(9)
          }
          case 10 => {
            _field.`type` match {
              case TType.I64 =>
                AdaptTProtocol.usedStartMarker(10)
                singleAsteriskComment = _root_.scala.Some(Request.readSingleAsteriskCommentValue(_iprot))
                AdaptTProtocol.usedEndMarker(10)
                AdaptTProtocol.unusedStartMarker(10)
                _iprot.offsetSkipI64()
                AdaptTProtocol.unusedEndMarker(10)
              case _actualType =>
                val _expectedType = TType.I64
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "singleAsteriskComment")
            }
            AdaptTProtocol.usedStartMarker(10)
            adapt.set_singleAsteriskComment(singleAsteriskComment)
            AdaptTProtocol.usedEndMarker(10)
          }
          case 11 => {
            _field.`type` match {
              case TType.I64 =>
                AdaptTProtocol.usedStartMarker(11)
                docStringComment = _root_.scala.Some(Request.readDocStringCommentValue(_iprot))
                AdaptTProtocol.usedEndMarker(11)
                AdaptTProtocol.unusedStartMarker(11)
                _iprot.offsetSkipI64()
                AdaptTProtocol.unusedEndMarker(11)
              case _actualType =>
                val _expectedType = TType.I64
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "docStringComment")
            }
            AdaptTProtocol.usedStartMarker(11)
            adapt.set_docStringComment(docStringComment)
            AdaptTProtocol.usedEndMarker(11)
          }
          case 12 => {
            _field.`type` match {
              case TType.STRUCT =>
                AdaptTProtocol.usedStartMarker(12)
                recRequest = _root_.scala.Some(Request.readRecRequestValue(_iprot))
                AdaptTProtocol.usedEndMarker(12)
                AdaptTProtocol.unusedStartMarker(12)
                _iprot.offsetSkipStruct()
                AdaptTProtocol.unusedEndMarker(12)
              case _actualType =>
                val _expectedType = TType.STRUCT
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "recRequest")
            }
            AdaptTProtocol.usedStartMarker(12)
            adapt.set_recRequest(recRequest)
            AdaptTProtocol.usedEndMarker(12)
          }
          case 13 => {
            _field.`type` match {
              case TType.STRING =>
                AdaptTProtocol.usedStartMarker(13)
                requiredField = Request.readRequiredFieldValue(_iprot)
                AdaptTProtocol.usedEndMarker(13)
                AdaptTProtocol.unusedStartMarker(13)
                _iprot.offsetSkipString()
                AdaptTProtocol.unusedEndMarker(13)
                _got_requiredField = true
              case _actualType =>
                val _expectedType = TType.STRING
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "requiredField")
            }
            AdaptTProtocol.usedStartMarker(13)
            adapt.set_requiredField(requiredField)
            AdaptTProtocol.usedEndMarker(13)
          }
          case 14 => {
            _field.`type` match {
              case TType.I64 =>
                AdaptTProtocol.usedStartMarker(14)
                constructionRequiredField = _root_.scala.Some(Request.readConstructionRequiredFieldValue(_iprot))
                AdaptTProtocol.usedEndMarker(14)
                AdaptTProtocol.unusedStartMarker(14)
                _iprot.offsetSkipI64()
                AdaptTProtocol.unusedEndMarker(14)
              case _actualType =>
                val _expectedType = TType.I64
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "constructionRequiredField")
            }
            AdaptTProtocol.usedStartMarker(14)
            adapt.set_constructionRequiredField(constructionRequiredField)
            AdaptTProtocol.usedEndMarker(14)
          }
          case 15 => {
            _field.`type` match {
              case TType.BYTE =>
                AdaptTProtocol.usedStartMarker(15)
                anInt8 = _root_.scala.Some(Request.readAnInt8Value(_iprot))
                AdaptTProtocol.usedEndMarker(15)
                AdaptTProtocol.unusedStartMarker(15)
                _iprot.offsetSkipBool()
                AdaptTProtocol.unusedEndMarker(15)
              case _actualType =>
                val _expectedType = TType.BYTE
                throw AdaptTProtocol.unexpectedTypeException(_expectedType, _actualType, "anInt8")
            }
            AdaptTProtocol.usedStartMarker(15)
            adapt.set_anInt8(anInt8)
            AdaptTProtocol.usedEndMarker(15)
          }

          case _ =>
            if (_passthroughFields == null)
              _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
            _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()

    if (!_got_requiredField) throw new TProtocolException("Required field 'requiredField' was not found in serialized data for struct Request")
    adapt.set__endOffset(_iprot.offset)
    if (_passthroughFields != null) {
      adapt.set__passthroughFields(_passthroughFields.result())
    }
    adapt
  }
}

/**
 * This is the base template for Adaptive decoding. This class gets pruned and
 * reloaded at runtime.
 */
private class Request__Adapt(
    _proto: AdaptTProtocol,
    _buf: Array[Byte],
    _start_offset: Int) extends Request {

  /**
   * In case any unexpected field is accessed, fallback to eager decoding.
   */
  private[this] lazy val delegate: Request = {
    val bytes = _root_.java.util.Arrays.copyOfRange(_buf, _start_offset, _end_offset)
    val proto = _proto.withBytes(bytes)
    Request.eagerDecode(proto)
  }

  private[this] var m_aList: _root_.scala.collection.Seq[String] = _
  def set_aList(aList: _root_.scala.collection.Seq[String]): Unit = m_aList = aList
  // This will be removed by ASM if field is unused.
  def aList: _root_.scala.collection.Seq[String] = m_aList
  // This will be removed by ASM if field is used otherwise renamed to aList.
  def delegated_aList: _root_.scala.collection.Seq[String] = delegate.aList

  private[this] var m_aSet: _root_.scala.collection.Set[Int] = _
  def set_aSet(aSet: _root_.scala.collection.Set[Int]): Unit = m_aSet = aSet
  // This will be removed by ASM if field is unused.
  def aSet: _root_.scala.collection.Set[Int] = m_aSet
  // This will be removed by ASM if field is used otherwise renamed to aSet.
  def delegated_aSet: _root_.scala.collection.Set[Int] = delegate.aSet

  private[this] var m_aMap: _root_.scala.collection.Map[Long, Long] = _
  def set_aMap(aMap: _root_.scala.collection.Map[Long, Long]): Unit = m_aMap = aMap
  // This will be removed by ASM if field is unused.
  def aMap: _root_.scala.collection.Map[Long, Long] = m_aMap
  // This will be removed by ASM if field is used otherwise renamed to aMap.
  def delegated_aMap: _root_.scala.collection.Map[Long, Long] = delegate.aMap

  private[this] var m_aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = _
  def set_aRequest(aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request]): Unit = m_aRequest = aRequest
  // This will be removed by ASM if field is unused.
  def aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = m_aRequest
  // This will be removed by ASM if field is used otherwise renamed to aRequest.
  def delegated_aRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Request] = delegate.aRequest

  private[this] var m_subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = _
  def set_subRequests(subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request]): Unit = m_subRequests = subRequests
  // This will be removed by ASM if field is unused.
  def subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = m_subRequests
  // This will be removed by ASM if field is used otherwise renamed to subRequests.
  def delegated_subRequests: _root_.scala.collection.Seq[com.twitter.scrooge.test.gold.thriftscala.Request] = delegate.subRequests

  private[this] var m_hasDefault: String = _
  def set_hasDefault(hasDefault: String): Unit = m_hasDefault = hasDefault
  // This will be removed by ASM if field is unused.
  def hasDefault: String = m_hasDefault
  // This will be removed by ASM if field is used otherwise renamed to hasDefault.
  def delegated_hasDefault: String = delegate.hasDefault

  private[this] var m_noComment: _root_.scala.Option[Long] = _
  def set_noComment(noComment: _root_.scala.Option[Long]): Unit = m_noComment = noComment
  // This will be removed by ASM if field is unused.
  def noComment: _root_.scala.Option[Long] = m_noComment
  // This will be removed by ASM if field is used otherwise renamed to noComment.
  def delegated_noComment: _root_.scala.Option[Long] = delegate.noComment

  private[this] var m_doubleSlashComment: _root_.scala.Option[Long] = _
  def set_doubleSlashComment(doubleSlashComment: _root_.scala.Option[Long]): Unit = m_doubleSlashComment = doubleSlashComment
  // This will be removed by ASM if field is unused.
  def doubleSlashComment: _root_.scala.Option[Long] = m_doubleSlashComment
  // This will be removed by ASM if field is used otherwise renamed to doubleSlashComment.
  def delegated_doubleSlashComment: _root_.scala.Option[Long] = delegate.doubleSlashComment

  private[this] var m_hashtagComment: _root_.scala.Option[Long] = _
  def set_hashtagComment(hashtagComment: _root_.scala.Option[Long]): Unit = m_hashtagComment = hashtagComment
  // This will be removed by ASM if field is unused.
  def hashtagComment: _root_.scala.Option[Long] = m_hashtagComment
  // This will be removed by ASM if field is used otherwise renamed to hashtagComment.
  def delegated_hashtagComment: _root_.scala.Option[Long] = delegate.hashtagComment

  private[this] var m_singleAsteriskComment: _root_.scala.Option[Long] = _
  def set_singleAsteriskComment(singleAsteriskComment: _root_.scala.Option[Long]): Unit = m_singleAsteriskComment = singleAsteriskComment
  // This will be removed by ASM if field is unused.
  def singleAsteriskComment: _root_.scala.Option[Long] = m_singleAsteriskComment
  // This will be removed by ASM if field is used otherwise renamed to singleAsteriskComment.
  def delegated_singleAsteriskComment: _root_.scala.Option[Long] = delegate.singleAsteriskComment

  private[this] var m_docStringComment: _root_.scala.Option[Long] = _
  def set_docStringComment(docStringComment: _root_.scala.Option[Long]): Unit = m_docStringComment = docStringComment
  // This will be removed by ASM if field is unused.
  def docStringComment: _root_.scala.Option[Long] = m_docStringComment
  // This will be removed by ASM if field is used otherwise renamed to docStringComment.
  def delegated_docStringComment: _root_.scala.Option[Long] = delegate.docStringComment

  private[this] var m_recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = _
  def set_recRequest(recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive]): Unit = m_recRequest = recRequest
  // This will be removed by ASM if field is unused.
  def recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = m_recRequest
  // This will be removed by ASM if field is used otherwise renamed to recRequest.
  def delegated_recRequest: _root_.scala.Option[com.twitter.scrooge.test.gold.thriftscala.Recursive] = delegate.recRequest

  private[this] var m_requiredField: String = _
  def set_requiredField(requiredField: String): Unit = m_requiredField = requiredField
  // This will be removed by ASM if field is unused.
  def requiredField: String = m_requiredField
  // This will be removed by ASM if field is used otherwise renamed to requiredField.
  def delegated_requiredField: String = delegate.requiredField

  private[this] var m_constructionRequiredField: _root_.scala.Option[Long] = _
  def set_constructionRequiredField(constructionRequiredField: _root_.scala.Option[Long]): Unit = m_constructionRequiredField = constructionRequiredField
  // This will be removed by ASM if field is unused.
  def constructionRequiredField: _root_.scala.Option[Long] = m_constructionRequiredField
  // This will be removed by ASM if field is used otherwise renamed to constructionRequiredField.
  def delegated_constructionRequiredField: _root_.scala.Option[Long] = delegate.constructionRequiredField

  private[this] var m_anInt8: _root_.scala.Option[Byte] = _
  def set_anInt8(anInt8: _root_.scala.Option[Byte]): Unit = m_anInt8 = anInt8
  // This will be removed by ASM if field is unused.
  def anInt8: _root_.scala.Option[Byte] = m_anInt8
  // This will be removed by ASM if field is used otherwise renamed to anInt8.
  def delegated_anInt8: _root_.scala.Option[Byte] = delegate.anInt8


  private[this] var _end_offset: Int = _
  def set__endOffset(offset: Int) = _end_offset = offset

  private[this] var __passthroughFields: immutable$Map[Short, TFieldBlob] = Request.NoPassthroughFields
  def set__passthroughFields(passthroughFields: immutable$Map[Short, TFieldBlob]): Unit =
    __passthroughFields = passthroughFields

  override def _passthroughFields: immutable$Map[Short, TFieldBlob] = __passthroughFields

  /*
  Override the super hash code to make it a lazy val rather than def.

  Calculating the hash code can be expensive, caching it where possible
  can provide significant performance wins. (Key in a hash map for instance)
  Usually not safe since the normal constructor will accept a mutable map or
  set as an arg
  Here however we control how the class is generated from serialized data.
  With the class private and the contract that we throw away our mutable references
  having the hash code lazy here is safe.
  */
  override lazy val hashCode: Int = super.hashCode

  override def write(_oprot: TProtocol): Unit = {
    _oprot match {
      case i: AdaptTProtocol => i.writeRaw(_buf, _start_offset, _end_offset - _start_offset)
      case _ => super.write(_oprot)
    }
  }
}
